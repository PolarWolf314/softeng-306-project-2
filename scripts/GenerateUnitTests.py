from typing import List, Dict
from GxlToDot import Graph, Node
import sys
import os


SCRIPT_PATH = os.path.dirname(os.path.realpath(__file__))
ROOT_PATH = os.path.abspath(os.path.join(SCRIPT_PATH, '..'))

def get_test_filename(node_count: int) -> str:
    """
    Returns the filename of the Java unit test file for the given number of nodes.
    """
    return f'OptimalSchedulerNodes{node_count}Test.java'


def get_test_file_paths_and_count(graphs: List[Graph], output_path: str) -> Dict[str, int]:
    """
    Returns a list of all the file paths that will be used to write the Java unit tests to and the number of 
    tests in that file.
    """

    file_paths_and_count = {}

    for graph in graphs:
        # Doing this for every graph is not efficient, but it's fine as we don't run this often
        filename = get_test_filename(len(graph.nodes))
        file_path = os.path.join(output_path, filename)

        if (file_path not in file_paths_and_count):
            file_paths_and_count[file_path] = 0
        file_paths_and_count[file_path] += 1

    return file_paths_and_count


def create_test_file_headers(file_paths_and_count: Dict[str, int]) -> None:
    """
    Writes the boilerplate header for each of the Java unit test files. There will be one file for each unique
    number of nodes in the given graphs.
    """

    for file_path in file_paths_and_count:
        test_count = file_paths_and_count[file_path]
        class_name = os.path.basename(file_path).split('.')[0]
        test_file_header = f"""package nz.ac.auckland.se306.group12.optimal;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import nz.ac.auckland.se306.group12.ScheduleValidator;
import nz.ac.auckland.se306.group12.TestUtil;
import nz.ac.auckland.se306.group12.models.Graph;
import nz.ac.auckland.se306.group12.models.Schedule;
import nz.ac.auckland.se306.group12.scheduler.Scheduler;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Timeout;
import org.junit.jupiter.api.Timeout.ThreadMode;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

/**
 * This class has been automatically generated by the GenerateUnitTests.py script.
 * Do not modify this file directly as it will be overwritten the next time the script is run.
 * <p>
 * The optimal schedules for each test have been sourced from 
 * <a href="https://parallel.auckland.ac.nz/OptimalTaskScheduling/OptimalSchedules.html">the amazing work</a>
 * done by the Parallel and Reconfigurable Computing Lab at the University of Auckland.
 */
@Timeout(value = 2, unit = TimeUnit.MINUTES, threadMode = ThreadMode.SEPARATE_THREAD)
public class {class_name} {{

    public static final int TOTAL_TESTS = {test_count};

    // Change this to adjust how many tests are run
    public static final int TEST_RUN_COUNT = 50;

    private static Set<Number> tests_to_run;

    /**
   * Randomly select {{@link #TEST_RUN_COUNT}} tests to run.
   */
    @BeforeAll
    public static void beforeAll() {{
        int num_to_run = Math.min(TEST_RUN_COUNT, TOTAL_TESTS);
        tests_to_run = new HashSet<>();
        while (tests_to_run.size() < num_to_run) {{
            tests_to_run.add((int) (Math.random() * TOTAL_TESTS));
        }}
    }}

    public boolean isTestActive(int testIndex) {{
        return tests_to_run.contains(testIndex);
    }}
"""
        # Open file in write mode to overwrite any existing content
        with open(file_path, 'w') as f:
            f.write(test_file_header)


def create_unit_test_files(graphs: List[Graph], output_path: str) -> None:
    """
    Generates the Java class files in the specified output path directory of the project with unit tests that
    verify the optimal schedulers we have designed for each of the given graphs. There will be one file for 
    each unique number of nodes in the given graphs.
    """

    file_paths_and_count = get_test_file_paths_and_count(graphs, output_path)
    create_test_file_headers(file_paths_and_count)

    test_indices = {}

    for graph in graphs:
        filename = os.path.join(output_path, get_test_filename(len(graph.nodes)))
        if filename not in test_indices:
            test_indices[filename] = 0
        else: 
            test_indices[filename] += 1
        
        with open (filename, 'a') as f:
            f.write(create_unit_test(graph, test_indices[filename]))

    for file_path in file_paths_and_count:
        with open(file_path, 'a') as f:
            f.write('\n}\n')


def create_unit_test(graph: Graph, test_index: int) -> str:
    """
    Creates a string representing a single Java unit test for the given graph.
    """
    method_name = f'testOptimal{to_valid_method_name(graph)}'

    return f"""
    @ParameterizedTest
    @MethodSource("nz.ac.auckland.se306.group12.TestUtil#getOptimalSchedulers")
    void {method_name}(Scheduler scheduler) {{
        Assumptions.assumeTrue(this.isTestActive({test_index}));

        Graph graph = TestUtil.loadGraph("./graphs/optimal/{len(graph.nodes)}-nodes/{graph.get_filename()}");
        int processorCount = {graph.processor_count};
        int expectedScheduleEndTime = {graph.optimal_schedule_end_time};

        Schedule actualSchedule = scheduler.schedule(graph, processorCount);

        Assertions.assertEquals(expectedScheduleEndTime, actualSchedule.getLatestEndTime());
        ScheduleValidator.assertValidSchedule(actualSchedule, graph);
    }} 
"""


def to_valid_method_name(graph: Graph) -> str:
    """
    Converts the name of the graph into a valid Java method name by replacing any invalid characters with
    suitable replacements.
    """
    return graph.name.replace('.', 'dot').replace('-', '_').replace('#', '')


def get_gxl_file_paths(path: str, limit = -1) -> List[str]:
    """
    Returns a list of all the file paths for the GXL files in the given directory. If a limit is specified,
    only up to that many file paths will be returned.
    """
    filenames = [os.path.join(path, filename) for filename in os.listdir(path) if filename.endswith('.gxl')]
    return filenames if limit <= 0 else filenames[:limit]


def generate_graphs(input_path: str, input_dot_graph_path: str, test_path: str, graph_limit: int) -> None:
    """
    Generates DOT files from the GXL files found in the given input path directory and outputs them at the input
    DOT graph path directory. The graph limit parameter specifies the maximum number of graphs it will retrieve from the
    input path. It also generates a Java class file with unit tests for each of the graphs in the test path director.
    """
    gxl_file_paths = get_gxl_file_paths(input_path, graph_limit)
    print(f'Found {len(gxl_file_paths)} GXL files in "{prettify_path(input_path)}"')

    graphs: List[Graph] = []
    for index, filename in enumerate(gxl_file_paths):
        graph = Graph(filename)
        if (graph.is_heterogenous): # We do not support heterogenous processors
            continue

        write_input_dot_graph(graph, input_dot_graph_path, index)
        graphs.append(graph)

    create_unit_test_files(graphs, test_path)


def write_input_dot_graph(graph: Graph, output_dir: str, index: int) -> None:
    """
    Writes the input DOT graph to the given output directory with the filename specified by the id of the
    GXL graph.
    """
    node_count_directory = os.path.join(output_dir, f"{len(graph.nodes)}-nodes")
    output_path = os.path.join(node_count_directory, graph.get_filename())

    if (not os.path.isdir(node_count_directory)):
        os.mkdir(node_count_directory)

    with open(output_path, 'w') as f:
        # Printing is slow so only print every 100 graphs
        if (index % 100 == 0):
            print(f'{index} - Writing input DOT graph to "{prettify_path(output_path)}"')
        f.write(graph.to_input_dot_graph() + '\n')

def prettify_path(path: str) -> str:
    """
    Returns a prettified version of the given path by not showing the root directory. This is used to make 
    the output of the script more readable.
    """
    return os.path.abspath(path).replace(ROOT_PATH, '<root>')


def main():
    """
    The entry point of this script. It converts GXL representations of task graphs and converts them into unit
    tests that can be run to verify the correctness of the optimal schedulers we have designed. It expects up 
    to two arguments:

    1. The input path of the GXL files to generate the unit tests from. By default, this is the current directory.
    2. The maximum number of GXL files to generate unit tests for. By default this is -1. Specifying -1 will generate
       unit tests for all GXL files in the input directory.
    """
    # By default, use the current directory
    input_path = sys.argv[1] if len(sys.argv) >= 2 else '.'
    graph_limit = int(sys.argv[2]) if len(sys.argv) >= 3 else -1

    input_dot_graph_path = os.path.join(ROOT_PATH, 'graphs', 'optimal')
    test_path = os.path.join(ROOT_PATH, 'src', 'test', 'java', 'nz', 'ac', 'auckland', 'se306', 'group12', 'optimal')

    if (not os.path.isdir(input_path)):
        raise FileNotFoundError(f'Expected input path "{prettify_path(input_path)}" to be a valid directory')
    if (not os.path.isdir(input_dot_graph_path)):
        raise FileNotFoundError(f'Expected the directory "{prettify_path(input_dot_graph_path)}" to exist')
    if (not os.path.isdir(test_path)):
        raise FileNotFoundError(f'Expected the directory "{prettify_path(test_path)}" to exist')

    generate_graphs(input_path, input_dot_graph_path, test_path, graph_limit)


if __name__ == '__main__':
    main()
